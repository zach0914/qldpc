import stim
import numpy as np
from numpy.linalg import matrix_power, matrix_rank
import matplotlib.pyplot as plt
from scipy.sparse import lil_matrix
import os
from tqdm import tqdm
import galois
import qldpc
from qldpc.codes.classical import ClassicalCode, HammingCode
from qldpc.codes.quantum import HGPCode
from utils import par2gen, get_classical_code, generate_HGP_code, par2gen, get_logicals, SGSOP

class Simulator:
    def __init__(self, ka, kb):
        self.code = generate_HGP_code(ka, kb)
        self.Hx, self.Hz = self.code.matrix_x, self.code.matrix_z
        self.Hx = np.array(self.Hx).astype(int)
        self.Hz = np.array(self.Hz).astype(int)
        self.n = self.Hx.shape[1]
        self.m = self.Hx.shape[0] + self.Hz.shape[0]
        self.k = self.n - self.m
        # print(f"parity_matrix_x: {self.Hx}\nparity_matrix_z: {self.Hz}")
        # print(f"parity_matrix_x.shape: {self.Hx.shape}\nparity_matrix_z.shape: {self.Hz.shape}")
    def check_orthogonal(self, matrix_a, matrix_b):
        """
        Check if two matrices are orthogonal.
        matrix_a: the first numpy matrix
        matrix_b: the second numpy matrix
        The matrices are orthogonal if their dot product is zero.
        """
        # if matrix_a.shape[1] != matrix_b.shape[1]:
            # raise ValueError("Matrices must have the same number of columns for orthogonality check.")
        commutator = np.dot(matrix_a, matrix_b.T) % 2  # 计算对易关系
        if np.any(commutator):
            print("Error: Matrices are not orthogonal!")

    def observables(self, logicals):
        """
        Generate a stim circuit from the logical operators of a quantum code.
        logicals: the logical operators for the code
        The circuit is generated by appending operations for each logical operator.
        """
        # logicals = np.array(logicals).astype(int)
        circuit = stim.Circuit()
        for i, logical in enumerate(logicals):
            include_qubits = np.where(logical == 1)[0]
            include_qubits = [-j-1 for j in include_qubits]
            circuit.append_operation("OBSERVABLE_INCLUDE", [stim.target_rec(q) for q in include_qubits])
        return circuit
    def create_initial_circuit(self, noise = 0.01, Theta = None, Pauli = None):
        """
        Generate a stim circuit from the stabilizer generators of a quantum code.
        matrix_x: the stabilizer generators for X-type errors
        matrix_z: the stabilizer generators for Z-type errors
        The circuit is generated by appending operations for each stabilizer generator.
        """
        self.check_orthogonal(self.Hx, self.Hz)
        Gx, col_Gx = par2gen(self.Hx)
        Gz, col_Gz = par2gen(self.Hz)
        logicals, generators = SGSOP(Gx, Gz, self.n)
        logX = np.array([l[1][self.n:] for l in logicals])
        logZ = np.array([l[0][:self.n] for l in logicals])
        self.circuit = stim.Circuit()    
        for log in logX:
            self.check_orthogonal(log, self.Hz)
        for log in logZ:
            self.check_orthogonal(log, self.Hx)
        # self.circuit.append("R", [i for i in range(n)])
        # print(self.circuit)
        for stabilizer in self.Hx:
            detector = []
            for i, qubit in enumerate(stabilizer):
                if qubit == 1:
                    detector.append(stim.target_x(i))
                    detector.append(stim.target_combiner())
            if detector != None:
                detector.pop()
            self.circuit.append_operation("MPP", detector)
        for stabilizer in self.Hz:
            detector = []
            for i, qubit in enumerate(stabilizer):
                if qubit == 1:
                    detector.append(stim.target_z(i))
                    detector.append(stim.target_combiner())
            if detector != None:
                detector.pop()
            self.circuit.append_operation("MPP", detector)
        self.circuit.append("DEPOLARIZE1", [i for i in range(self.n)], noise)
        # self.circuit.append("X_ERROR", [0, 1, 2], 0.1)

        for stabilizer in self.Hx:
            detector = []
            for i, qubit in enumerate(stabilizer):
                if qubit == 1:
                    detector.append(stim.target_x(i))
                    detector.append(stim.target_combiner())
            if detector != None:
                detector.pop()
            self.circuit.append_operation("MPP", detector)
        for stabilizer in self.Hz:
            detector = []
            for i, qubit in enumerate(stabilizer):
                if qubit == 1:
                    detector.append(stim.target_z(i))
                    detector.append(stim.target_combiner())
            if detector != None:
                detector.pop()
            self.circuit.append_operation("MPP", detector)

        for i in range(self.m):
            self.circuit.append("DETECTOR", [stim.target_rec(-i-1), stim.target_rec(-i-1-self.m)])
        # self.circuit.append_operation("H", [i for i in range(n)])
        self.circuit.append_operation("M", [i for i in range(self.n)][::-1])
        self.circuit += self.observables(logZ)
        # Add a measurement operation for the logical qubits